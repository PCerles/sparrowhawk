import 'cardinal.grm' as c;
import 'ordinal.grm' as o;
import 'date.grm' as d;
import 'measure.grm' as M;
import 'money.grm' as m;
import 'punctuation.grm' as p;
import 'time.grm' as t;
import '../util.grm' as u;
import 'word.grm' as w;
import 'decimal.grm' as D;
import 'telephone.grm' as T;

types = D.DECIMAL | o.ORDINAL | (c.CARDINAL <2.0>) | d.DATE | M.MEASURE | m.MONEY | (w.WORD <3.0>) | t.TIME | T.TELEPHONE;

token_plus_punct = u.I["tokens { "] types u.I[" }"];

# token_plus_punct = (p.PUNCT u.I[" "])* token (u.I[" "] p.PUNCT)*;

# Collection of all possible semiotic classes, including ordinary words.

export TOKENIZE_AND_CLASSIFY =
  Optimize[token_plus_punct (" " token_plus_punct)*]
;

export TOKENIZE_AND_CLASSIFY_INVERSE = 
  Optimize[Invert[TOKENIZE_AND_CLASSIFY]]
;
